#!/usr/bin/env python3
"""
Hex Video Player
Reads hex video data generated by the video converter and displays it as an animated video.
Supports both C array format (.h files) and other text formats.
"""

import numpy as np
import cv2
import re
import time
import argparse
import sys
from pathlib import Path


class HexVideoPlayer:
    def __init__(self, data_file, scale_factor=20, fps=10, loop=True):
        """
        Initialize the hex video player
        
        Args:
            data_file (str): Path to the hex data file
            scale_factor (int): Scaling factor for display (default: 20x)
            fps (int): Playback framerate
            loop (bool): Whether to loop the video
        """
        self.data_file = data_file
        self.scale_factor = scale_factor
        self.fps = fps
        self.loop = loop
        self.frames = []
        self.frame_width = 0
        self.frame_height = 0
        self.frame_channels = 1
        self.frame_count = 0
        
    def parse_c_array_file(self, content):
        """Parse C array format (.h files)"""
        # Extract frame dimensions and count from defines
        width_match = re.search(r'#define\s+FRAME_WIDTH\s+(\d+)', content)
        height_match = re.search(r'#define\s+FRAME_HEIGHT\s+(\d+)', content)
        count_match = re.search(r'#define\s+FRAME_COUNT\s+(\d+)', content)
        channels_match = re.search(r'#define\s+FRAME_CHANNELS\s+(\d+)', content)
        
        if not all([width_match, height_match, count_match]):
            raise ValueError("Could not find frame dimensions in C array file")
        
        self.frame_width = int(width_match.group(1))
        self.frame_height = int(height_match.group(1))
        self.frame_count = int(count_match.group(1))
        self.frame_channels = int(channels_match.group(1)) if channels_match else 1
        
        print(f"Detected: {self.frame_count} frames, {self.frame_width}x{self.frame_height}, {self.frame_channels} channel(s)")
        
        # Extract hex values from the array
        # Find the array data between { and };
        array_pattern = r'const\s+unsigned\s+char\s+\w+\[.*?\]\s*=\s*\{(.*?)\};'
        array_match = re.search(array_pattern, content, re.DOTALL)
        
        if not array_match:
            raise ValueError("Could not find array data in C file")
        
        array_data = array_match.group(1)
        
        # Extract all hex values (0x## format)
        hex_values = re.findall(r'0x([0-9A-Fa-f]{2})', array_data)
        
        if not hex_values:
            raise ValueError("No hex values found in array data")
        
        # Convert hex strings to integers
        pixel_data = [int(hex_val, 16) for hex_val in hex_values]
        
        # Calculate expected size
        expected_size = self.frame_count * self.frame_width * self.frame_height * self.frame_channels
        
        if len(pixel_data) != expected_size:
            print(f"Warning: Expected {expected_size} values, found {len(pixel_data)}")
            # Adjust frame count if needed
            actual_frames = len(pixel_data) // (self.frame_width * self.frame_height * self.frame_channels)
            if actual_frames != self.frame_count:
                print(f"Adjusting frame count to {actual_frames}")
                self.frame_count = actual_frames
        
        return pixel_data
    
    def parse_plain_hex_file(self, content):
        """Parse plain hex format files"""
        # Try to extract dimensions from comments
        width_match = re.search(r'#.*?(\d+)x(\d+)', content)
        if width_match:
            self.frame_width = int(width_match.group(1))
            self.frame_height = int(width_match.group(2))
        else:
            # Default dimensions if not found
            self.frame_width = 8
            self.frame_height = 8
        
        # Extract hex values (both 0x## and plain ## formats)
        hex_values = re.findall(r'(?:0x)?([0-9A-Fa-f]{2})', content)
        pixel_data = [int(hex_val, 16) for hex_val in hex_values]
        
        # Calculate frame count
        pixels_per_frame = self.frame_width * self.frame_height * self.frame_channels
        self.frame_count = len(pixel_data) // pixels_per_frame
        
        return pixel_data
    
    def load_data(self):
        """Load and parse the hex data file"""
        try:
            with open(self.data_file, 'r') as f:
                content = f.read()
        except FileNotFoundError:
            raise FileNotFoundError(f"Data file not found: {self.data_file}")
        
        # Determine file format based on content
        if 'const unsigned char' in content and '#define' in content:
            print("Detected C array format")
            pixel_data = self.parse_c_array_file(content)
        else:
            print("Detected plain hex format")
            pixel_data = self.parse_plain_hex_file(content)
        
        # Convert to frames
        pixels_per_frame = self.frame_width * self.frame_height * self.frame_channels
        
        for i in range(self.frame_count):
            start_idx = i * pixels_per_frame
            end_idx = start_idx + pixels_per_frame
            frame_data = pixel_data[start_idx:end_idx]
            
            if self.frame_channels == 1:
                # Grayscale
                frame = np.array(frame_data, dtype=np.uint8).reshape(
                    (self.frame_height, self.frame_width)
                )
            else:
                # Color (assume BGR format)
                frame = np.array(frame_data, dtype=np.uint8).reshape(
                    (self.frame_height, self.frame_width, self.frame_channels)
                )
            
            self.frames.append(frame)
        
        print(f"Loaded {len(self.frames)} frames successfully")
    
    def play_video(self, save_as=None):
        """
        Play the video with OpenCV
        
        Args:
            save_as (str): Optional path to save the video as MP4
        """
        if not self.frames:
            raise ValueError("No frames loaded. Call load_data() first.")
        
        # Create window
        cv2.namedWindow('Hex Video Player', cv2.WINDOW_AUTOSIZE)
        
        # Video writer setup if saving
        video_writer = None
        if save_as:
            fourcc = cv2.VideoWriter_fourcc(*'mp4v')
            output_size = (
                self.frame_width * self.scale_factor,
                self.frame_height * self.scale_factor
            )
            video_writer = cv2.VideoWriter(save_as, fourcc, self.fps, output_size, 
                                         isColor=(self.frame_channels > 1))
            print(f"Saving video to: {save_as}")
        
        frame_delay = 1.0 / self.fps
        
        try:
            while True:
                for i, frame in enumerate(self.frames):
                    # Scale up the frame for better visibility
                    if self.frame_channels == 1:
                        # For grayscale, convert to 3-channel for display
                        display_frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)
                    else:
                        display_frame = frame.copy()
                    
                    # Scale up using nearest neighbor to maintain pixelated look
                    scaled_frame = cv2.resize(
                        display_frame,
                        (self.frame_width * self.scale_factor, self.frame_height * self.scale_factor),
                        interpolation=cv2.INTER_NEAREST
                    )
                    
                    # Add frame info overlay
                    font = cv2.FONT_HERSHEY_SIMPLEX
                    font_scale = 0.5
                    color = (0, 255, 0)  # Green
                    thickness = 1
                    
                    text = f"Frame: {i+1}/{len(self.frames)}"
                    text_size = cv2.getTextSize(text, font, font_scale, thickness)[0]
                    text_x = scaled_frame.shape[1] - text_size[0] - 10
                    text_y = 20
                    
                    cv2.putText(scaled_frame, text, (text_x, text_y), font, font_scale, color, thickness)
                    
                    # Display frame
                    cv2.imshow('Hex Video Player', scaled_frame)
                    
                    # Save frame if recording
                    if video_writer:
                        if self.frame_channels == 1:
                            # Convert grayscale to color for video writer
                            save_frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)
                        else:
                            save_frame = frame.copy()
                        
                        save_frame = cv2.resize(
                            save_frame,
                            (self.frame_width * self.scale_factor, self.frame_height * self.scale_factor),
                            interpolation=cv2.INTER_NEAREST
                        )
                        video_writer.write(save_frame)
                    
                    # Check for exit
                    key = cv2.waitKey(int(frame_delay * 1000)) & 0xFF
                    if key == ord('q') or key == 27:  # 'q' or ESC
                        raise KeyboardInterrupt
                    elif key == ord(' '):  # Space to pause
                        cv2.waitKey(0)
                
                if not self.loop:
                    break
                    
        except KeyboardInterrupt:
            print("\nPlayback stopped by user")
        
        finally:
            if video_writer:
                video_writer.release()
                print(f"Video saved successfully")
            cv2.destroyAllWindows()
    
    def export_frames(self, output_dir):
        """Export individual frames as PNG files"""
        if not self.frames:
            raise ValueError("No frames loaded. Call load_data() first.")
        
        output_path = Path(output_dir)
        output_path.mkdir(exist_ok=True)
        
        for i, frame in enumerate(self.frames):
            # Scale up for better visibility
            if self.frame_channels == 1:
                display_frame = frame
            else:
                display_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            
            scaled_frame = cv2.resize(
                display_frame,
                (self.frame_width * self.scale_factor, self.frame_height * self.scale_factor),
                interpolation=cv2.INTER_NEAREST
            )
            
            filename = output_path / f"frame_{i:04d}.png"
            cv2.imwrite(str(filename), scaled_frame)
        
        print(f"Exported {len(self.frames)} frames to {output_dir}")
    
    def get_stats(self):
        """Get video statistics"""
        if not self.frames:
            return "No data loaded"
        
        total_pixels = len(self.frames) * self.frame_width * self.frame_height * self.frame_channels
        duration = len(self.frames) / self.fps
        
        return f"""
Video Statistics:
- Frames: {len(self.frames)}
- Resolution: {self.frame_width}x{self.frame_height}
- Channels: {self.frame_channels} ({'Grayscale' if self.frame_channels == 1 else 'Color'})
- Total pixels: {total_pixels:,}
- Duration: {duration:.2f} seconds @ {self.fps} FPS
- Display scale: {self.scale_factor}x ({self.frame_width * self.scale_factor}x{self.frame_height * self.scale_factor})
"""


def main():
    parser = argparse.ArgumentParser(description="Play hex video data generated by video converter")
    parser.add_argument("input", help="Input hex data file (.h, .txt, etc.)")
    parser.add_argument("-s", "--scale", type=int, default=20, help="Display scale factor (default: 20)")
    parser.add_argument("-f", "--fps", type=int, default=10, help="Playback framerate (default: 10)")
    parser.add_argument("--no-loop", action="store_true", help="Don't loop the video")
    parser.add_argument("--save", help="Save as MP4 video file")
    parser.add_argument("--export-frames", help="Export individual frames to directory")
    parser.add_argument("--stats-only", action="store_true", help="Show statistics only, don't play")
    
    args = parser.parse_args()
    
    try:
        # Create player
        player = HexVideoPlayer(
            data_file=args.input,
            scale_factor=args.scale,
            fps=args.fps,
            loop=not args.no_loop
        )
        
        # Load data
        print("Loading hex data...")
        player.load_data()
        
        # Show statistics
        print(player.get_stats())
        
        if args.stats_only:
            return
        
        # Export frames if requested
        if args.export_frames:
            print("Exporting frames...")
            player.export_frames(args.export_frames)
        
        # Play video
        if not args.export_frames or args.save:
            print(f"Playing video... (Press 'q' or ESC to quit, SPACE to pause)")
            player.play_video(save_as=args.save)
        
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
